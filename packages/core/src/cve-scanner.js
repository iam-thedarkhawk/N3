"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CVEScanner = void 0;
const axios_1 = __importDefault(require("axios"));
const cve_parser_1 = require("./cve-parser");
class CVEScanner {
    constructor() {
        this.templates = [];
        this.parser = new cve_parser_1.CVETemplateParser();
        this.config = {
            templatesDir: '',
            timeout: 10000,
            followRedirects: true,
            userAgent: 'N3-CVE-Scanner/1.0',
        };
    }
    /**
     * Initialize scanner with templates
     */
    async initialize(config) {
        this.config = { ...this.config, ...config };
        this.templates = await this.parser.loadTemplates(config.templatesDir);
        if (config.severities) {
            this.templates = this.parser.filterBySeverity(this.templates, config.severities);
        }
        if (config.tags) {
            this.templates = this.parser.filterByTags(this.templates, config.tags);
        }
    }
    /**
     * Scan a target URL with all loaded templates
     */
    async scan(targetUrl) {
        const vulnerabilities = [];
        for (const template of this.templates) {
            const result = await this.scanWithTemplate(targetUrl, template);
            if (result.vulnerable) {
                vulnerabilities.push(result);
            }
        }
        return {
            target: targetUrl,
            timestamp: Date.now(),
            totalChecks: this.templates.length,
            vulnerabilities,
            summary: this.generateSummary(vulnerabilities),
        };
    }
    /**
     * Scan with a specific CVE template
     */
    async scanWithTemplate(targetUrl, template) {
        for (const request of template.requests) {
            for (const path of request.path) {
                try {
                    const fullUrl = this.buildUrl(targetUrl, path);
                    const response = await this.makeRequest(fullUrl, request);
                    const matchResult = this.evaluateMatchers(response, request.matchers, request['matchers-condition'] || 'or');
                    if (matchResult.matched) {
                        return {
                            template,
                            vulnerable: true,
                            matchedPath: path,
                            matchedMatcher: matchResult.matcher,
                            response: {
                                statusCode: response.status,
                                body: response.data,
                                headers: response.headers,
                            },
                        };
                    }
                }
                catch (error) {
                    // Continue to next path on error
                    continue;
                }
            }
        }
        return {
            template,
            vulnerable: false,
        };
    }
    /**
     * Make HTTP request
     */
    async makeRequest(url, request) {
        return await (0, axios_1.default)({
            method: request.method,
            url,
            headers: {
                'User-Agent': this.config.userAgent,
                ...request.headers,
            },
            data: request.body,
            timeout: this.config.timeout,
            maxRedirects: this.config.followRedirects ? 5 : 0,
            validateStatus: () => true, // Don't throw on any status code
        });
    }
    /**
     * Evaluate matchers against response
     */
    evaluateMatchers(response, matchers, condition) {
        const results = matchers.map(matcher => this.evaluateMatcher(response, matcher));
        if (condition === 'and') {
            const allMatched = results.every(r => r);
            return {
                matched: allMatched,
                matcher: allMatched ? 'all-matchers' : undefined,
            };
        }
        else {
            const anyMatched = results.some(r => r);
            const matchedIndex = results.findIndex(r => r);
            return {
                matched: anyMatched,
                matcher: matchedIndex >= 0 ? matchers[matchedIndex].type : undefined,
            };
        }
    }
    /**
     * Evaluate a single matcher
     */
    evaluateMatcher(response, matcher) {
        let result = false;
        switch (matcher.type) {
            case 'word':
                result = this.matchWords(response, matcher);
                break;
            case 'regex':
                result = this.matchRegex(response, matcher);
                break;
            case 'status':
                result = this.matchStatus(response, matcher);
                break;
            case 'dsl':
                result = this.matchDsl(response, matcher);
                break;
        }
        return matcher.negative ? !result : result;
    }
    /**
     * Match words in response
     */
    matchWords(response, matcher) {
        if (!matcher.words)
            return false;
        const content = this.getMatcherContent(response, matcher.part);
        const condition = matcher.condition || 'or';
        if (condition === 'and') {
            return matcher.words.every(word => content.includes(word));
        }
        else {
            return matcher.words.some(word => content.includes(word));
        }
    }
    /**
     * Match regex patterns
     */
    matchRegex(response, matcher) {
        if (!matcher.regex)
            return false;
        const content = this.getMatcherContent(response, matcher.part);
        const condition = matcher.condition || 'or';
        if (condition === 'and') {
            return matcher.regex.every(pattern => new RegExp(pattern, 'i').test(content));
        }
        else {
            return matcher.regex.some(pattern => new RegExp(pattern, 'i').test(content));
        }
    }
    /**
     * Match status codes
     */
    matchStatus(response, matcher) {
        if (!matcher.status)
            return false;
        return matcher.status.includes(response.status);
    }
    /**
     * Match DSL expressions
     */
    matchDsl(response, matcher) {
        if (!matcher.dsl)
            return false;
        const condition = matcher.condition || 'or';
        const results = matcher.dsl.map(expr => this.evaluateDslExpression(response, expr));
        if (condition === 'and') {
            return results.every(r => r);
        }
        else {
            return results.some(r => r);
        }
    }
    /**
     * Evaluate DSL expression
     */
    evaluateDslExpression(response, expression) {
        const body = typeof response.data === 'string' ? response.data : JSON.stringify(response.data);
        // Simple DSL evaluation for contains()
        if (expression.includes('contains(body,')) {
            const match = expression.match(/contains\(body,\s*['"](.+?)['"]\)/);
            if (match) {
                return body.includes(match[1]);
            }
        }
        // Status code check
        if (expression.includes('status_code')) {
            const match = expression.match(/status_code\s*==\s*(\d+)/);
            if (match) {
                return response.status === parseInt(match[1], 10);
            }
        }
        // Length check
        if (expression.includes('len(body)')) {
            const match = expression.match(/len\(body\)\s*([><=]+)\s*(\d+)/);
            if (match) {
                const operator = match[1];
                const value = parseInt(match[2], 10);
                const bodyLength = body.length;
                switch (operator) {
                    case '>': return bodyLength > value;
                    case '<': return bodyLength < value;
                    case '>=': return bodyLength >= value;
                    case '<=': return bodyLength <= value;
                    case '==': return bodyLength === value;
                    default: return false;
                }
            }
        }
        return false;
    }
    /**
     * Get content from response based on matcher part
     */
    getMatcherContent(response, part) {
        switch (part) {
            case 'header':
                return JSON.stringify(response.headers);
            case 'body':
            default:
                return typeof response.data === 'string' ? response.data : JSON.stringify(response.data);
        }
    }
    /**
     * Build full URL from base and path
     */
    buildUrl(baseUrl, path) {
        // Replace {{BaseURL}} placeholder
        const fullPath = path.replace('{{BaseURL}}', baseUrl);
        // If path already contains full URL, return it
        if (fullPath.startsWith('http')) {
            return fullPath;
        }
        // Combine base URL and path
        const base = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
        const pathPart = path.startsWith('/') ? path : `/${path}`;
        return base + pathPart;
    }
    /**
     * Generate summary from scan results
     */
    generateSummary(results) {
        return {
            critical: results.filter(r => r.template.info.severity === 'critical').length,
            high: results.filter(r => r.template.info.severity === 'high').length,
            medium: results.filter(r => r.template.info.severity === 'medium').length,
            low: results.filter(r => r.template.info.severity === 'low').length,
            info: results.filter(r => r.template.info.severity === 'info').length,
        };
    }
    /**
     * Get all loaded templates
     */
    getTemplates() {
        return this.templates;
    }
}
exports.CVEScanner = CVEScanner;
