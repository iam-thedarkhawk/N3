import * as yaml from 'js-yaml';
import { readFile } from 'fs/promises';
import { glob } from 'glob';
import * as path from 'path';
import { CVETemplate } from './cve-types';

export class CVETemplateParser {
  /**
   * Load all CVE templates from a directory
   */
  async loadTemplates(directory: string): Promise<CVETemplate[]> {
    const templateFiles = await glob(path.join(directory, '**/*.yaml'));
    const templates: CVETemplate[] = [];

    for (const file of templateFiles) {
      try {
        const template = await this.parseTemplate(file);
        templates.push(template);
      } catch (error: any) {
        console.warn(`Failed to parse CVE template ${file}:`, error.message);
      }
    }

    return templates;
  }

  /**
   * Parse a single CVE template file
   */
  async parseTemplate(filePath: string): Promise<CVETemplate> {
    const content = await readFile(filePath, 'utf-8');
    const parsed = yaml.load(content) as any;

    this.validateTemplate(parsed);

    return {
      id: parsed.id,
      info: {
        name: parsed.info.name,
        author: parsed.info.author || 'unknown',
        severity: parsed.info.severity || 'info',
        description: parsed.info.description || '',
        reference: Array.isArray(parsed.info.reference) 
          ? parsed.info.reference 
          : [parsed.info.reference],
        tags: parsed.info.tags ? parsed.info.tags.split(',').map((t: string) => t.trim()) : [],
      },
      requests: this.parseRequests(parsed.requests),
    };
  }

  /**
   * Parse request definitions
   */
  private parseRequests(requests: any[]): any[] {
    return requests.map(req => ({
      method: req.method || 'GET',
      path: Array.isArray(req.path) ? req.path : [req.path],
      headers: req.headers || {},
      body: req.body,
      'matchers-condition': req['matchers-condition'] || 'or',
      matchers: this.parseMatchers(req.matchers || []),
    }));
  }

  /**
   * Parse matcher definitions
   */
  private parseMatchers(matchers: any[]): any[] {
    return matchers.map(matcher => ({
      type: matcher.type,
      part: matcher.part || 'body',
      words: matcher.words,
      regex: matcher.regex,
      status: matcher.status,
      dsl: matcher.dsl,
      condition: matcher.condition || 'or',
      negative: matcher.negative || false,
    }));
  }

  /**
   * Validate template structure
   */
  private validateTemplate(template: any): void {
    if (!template.id) {
      throw new Error('Template missing required field: id');
    }

    if (!template.info) {
      throw new Error('Template missing required field: info');
    }

    if (!template.requests || !Array.isArray(template.requests)) {
      throw new Error('Template missing required field: requests (must be array)');
    }
  }

  /**
   * Filter templates by severity
   */
  filterBySeverity(templates: CVETemplate[], severities: string[]): CVETemplate[] {
    return templates.filter(t => severities.includes(t.info.severity));
  }

  /**
   * Filter templates by tags
   */
  filterByTags(templates: CVETemplate[], tags: string[]): CVETemplate[] {
    return templates.filter(t => 
      t.info.tags.some(tag => tags.includes(tag))
    );
  }

  /**
   * Get template by ID
   */
  getTemplateById(templates: CVETemplate[], id: string): CVETemplate | undefined {
    return templates.find(t => t.id === id);
  }
}
