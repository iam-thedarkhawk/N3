import axios, { AxiosResponse } from 'axios';
import { CVETemplate, CVERequest, CVEMatcher, CVEScanResult, CVEReport } from './cve-types';
import { CVETemplateParser } from './cve-parser';

export interface CVEScannerConfig {
  templatesDir: string;
  timeout?: number;
  followRedirects?: boolean;
  userAgent?: string;
  severities?: string[];
  tags?: string[];
}

export class CVEScanner {
  private parser: CVETemplateParser;
  private templates: CVETemplate[] = [];
  private config: CVEScannerConfig;

  constructor() {
    this.parser = new CVETemplateParser();
    this.config = {
      templatesDir: '',
      timeout: 10000,
      followRedirects: true,
      userAgent: 'N3-CVE-Scanner/1.0',
    };
  }

  /**
   * Initialize scanner with templates
   */
  async initialize(config: CVEScannerConfig): Promise<void> {
    this.config = { ...this.config, ...config };
    this.templates = await this.parser.loadTemplates(config.templatesDir);

    if (config.severities) {
      this.templates = this.parser.filterBySeverity(this.templates, config.severities);
    }

    if (config.tags) {
      this.templates = this.parser.filterByTags(this.templates, config.tags);
    }
  }

  /**
   * Scan a target URL with all loaded templates
   */
  async scan(targetUrl: string): Promise<CVEReport> {
    const vulnerabilities: CVEScanResult[] = [];

    for (const template of this.templates) {
      const result = await this.scanWithTemplate(targetUrl, template);
      if (result.vulnerable) {
        vulnerabilities.push(result);
      }
    }

    return {
      target: targetUrl,
      timestamp: Date.now(),
      totalChecks: this.templates.length,
      vulnerabilities,
      summary: this.generateSummary(vulnerabilities),
    };
  }

  /**
   * Scan with a specific CVE template
   */
  private async scanWithTemplate(
    targetUrl: string,
    template: CVETemplate
  ): Promise<CVEScanResult> {
    for (const request of template.requests) {
      for (const path of request.path) {
        try {
          const fullUrl = this.buildUrl(targetUrl, path);
          const response = await this.makeRequest(fullUrl, request);

          const matchResult = this.evaluateMatchers(
            response,
            request.matchers,
            request['matchers-condition'] || 'or'
          );

          if (matchResult.matched) {
            return {
              template,
              vulnerable: true,
              matchedPath: path,
              matchedMatcher: matchResult.matcher,
              response: {
                statusCode: response.status,
                body: response.data,
                headers: response.headers as Record<string, string>,
              },
            };
          }
        } catch (error: any) {
          // Continue to next path on error
          continue;
        }
      }
    }

    return {
      template,
      vulnerable: false,
    };
  }

  /**
   * Make HTTP request
   */
  private async makeRequest(url: string, request: CVERequest): Promise<AxiosResponse> {
    return await axios({
      method: request.method,
      url,
      headers: {
        'User-Agent': this.config.userAgent,
        ...request.headers,
      },
      data: request.body,
      timeout: this.config.timeout,
      maxRedirects: this.config.followRedirects ? 5 : 0,
      validateStatus: () => true, // Don't throw on any status code
    });
  }

  /**
   * Evaluate matchers against response
   */
  private evaluateMatchers(
    response: AxiosResponse,
    matchers: CVEMatcher[],
    condition: 'and' | 'or'
  ): { matched: boolean; matcher?: string } {
    const results = matchers.map(matcher => this.evaluateMatcher(response, matcher));

    if (condition === 'and') {
      const allMatched = results.every(r => r);
      return {
        matched: allMatched,
        matcher: allMatched ? 'all-matchers' : undefined,
      };
    } else {
      const anyMatched = results.some(r => r);
      const matchedIndex = results.findIndex(r => r);
      return {
        matched: anyMatched,
        matcher: matchedIndex >= 0 ? matchers[matchedIndex].type : undefined,
      };
    }
  }

  /**
   * Evaluate a single matcher
   */
  private evaluateMatcher(response: AxiosResponse, matcher: CVEMatcher): boolean {
    let result = false;

    switch (matcher.type) {
      case 'word':
        result = this.matchWords(response, matcher);
        break;
      case 'regex':
        result = this.matchRegex(response, matcher);
        break;
      case 'status':
        result = this.matchStatus(response, matcher);
        break;
      case 'dsl':
        result = this.matchDsl(response, matcher);
        break;
    }

    return matcher.negative ? !result : result;
  }

  /**
   * Match words in response
   */
  private matchWords(response: AxiosResponse, matcher: CVEMatcher): boolean {
    if (!matcher.words) return false;

    const content = this.getMatcherContent(response, matcher.part);
    const condition = matcher.condition || 'or';

    if (condition === 'and') {
      return matcher.words.every(word => content.includes(word));
    } else {
      return matcher.words.some(word => content.includes(word));
    }
  }

  /**
   * Match regex patterns
   */
  private matchRegex(response: AxiosResponse, matcher: CVEMatcher): boolean {
    if (!matcher.regex) return false;

    const content = this.getMatcherContent(response, matcher.part);
    const condition = matcher.condition || 'or';

    if (condition === 'and') {
      return matcher.regex.every(pattern => new RegExp(pattern, 'i').test(content));
    } else {
      return matcher.regex.some(pattern => new RegExp(pattern, 'i').test(content));
    }
  }

  /**
   * Match status codes
   */
  private matchStatus(response: AxiosResponse, matcher: CVEMatcher): boolean {
    if (!matcher.status) return false;
    return matcher.status.includes(response.status);
  }

  /**
   * Match DSL expressions
   */
  private matchDsl(response: AxiosResponse, matcher: CVEMatcher): boolean {
    if (!matcher.dsl) return false;

    const condition = matcher.condition || 'or';
    const results = matcher.dsl.map(expr => this.evaluateDslExpression(response, expr));

    if (condition === 'and') {
      return results.every(r => r);
    } else {
      return results.some(r => r);
    }
  }

  /**
   * Evaluate DSL expression
   */
  private evaluateDslExpression(response: AxiosResponse, expression: string): boolean {
    const body = typeof response.data === 'string' ? response.data : JSON.stringify(response.data);
    
    // Simple DSL evaluation for contains()
    if (expression.includes('contains(body,')) {
      const match = expression.match(/contains\(body,\s*['"](.+?)['"]\)/);
      if (match) {
        return body.includes(match[1]);
      }
    }

    // Status code check
    if (expression.includes('status_code')) {
      const match = expression.match(/status_code\s*==\s*(\d+)/);
      if (match) {
        return response.status === parseInt(match[1], 10);
      }
    }

    // Length check
    if (expression.includes('len(body)')) {
      const match = expression.match(/len\(body\)\s*([><=]+)\s*(\d+)/);
      if (match) {
        const operator = match[1];
        const value = parseInt(match[2], 10);
        const bodyLength = body.length;

        switch (operator) {
          case '>': return bodyLength > value;
          case '<': return bodyLength < value;
          case '>=': return bodyLength >= value;
          case '<=': return bodyLength <= value;
          case '==': return bodyLength === value;
          default: return false;
        }
      }
    }

    return false;
  }

  /**
   * Get content from response based on matcher part
   */
  private getMatcherContent(response: AxiosResponse, part?: string): string {
    switch (part) {
      case 'header':
        return JSON.stringify(response.headers);
      case 'body':
      default:
        return typeof response.data === 'string' ? response.data : JSON.stringify(response.data);
    }
  }

  /**
   * Build full URL from base and path
   */
  private buildUrl(baseUrl: string, path: string): string {
    // Replace {{BaseURL}} placeholder
    const fullPath = path.replace('{{BaseURL}}', baseUrl);
    
    // If path already contains full URL, return it
    if (fullPath.startsWith('http')) {
      return fullPath;
    }

    // Combine base URL and path
    const base = baseUrl.endsWith('/') ? baseUrl.slice(0, -1) : baseUrl;
    const pathPart = path.startsWith('/') ? path : `/${path}`;
    return base + pathPart;
  }

  /**
   * Generate summary from scan results
   */
  private generateSummary(results: CVEScanResult[]): {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  } {
    return {
      critical: results.filter(r => r.template.info.severity === 'critical').length,
      high: results.filter(r => r.template.info.severity === 'high').length,
      medium: results.filter(r => r.template.info.severity === 'medium').length,
      low: results.filter(r => r.template.info.severity === 'low').length,
      info: results.filter(r => r.template.info.severity === 'info').length,
    };
  }

  /**
   * Get all loaded templates
   */
  getTemplates(): CVETemplate[] {
    return this.templates;
  }
}
